// 순서쌍의 개수
// 순서쌍이란 두 개의 숫자를 순서를 정하여 짝지어 나타낸 쌍으로 (a, b)로 표기합니다. 자연수 n이 매개변수로 주어질 때 두 숫자의 곱이 n인 자연수 순서쌍의 개수를 return하도록 solution 함수를 완성해주세요.

// 제한사항
// 1 ≤ n ≤ 1,000,000
// 입출력 예
// n	result
// 20	6
// 100	9
// 입출력 예 설명
// 입출력 예 #1

// n이 20 이므로 곱이 20인 순서쌍은 (1, 20), (2, 10), (4, 5), (5, 4), (10, 2), (20, 1) 이므로 6을 return합니다.
// 입출력 예 #2

// n이 100 이므로 곱이 100인 순서쌍은 (1, 100), (2, 50), (4, 25), (5, 20), (10, 10), (20, 5), (25, 4), (50, 2), (100, 1) 이므로 9를 return합니다.

// ------------------------------------------------------------------------------------------

// 나의 풀이

function solution(n) {
  let answer = [];
  for (let i = 1; i <= n; i++) {
    n % i === 0 ? answer.push(i) : undefined;
  }
  return answer.length;
  // 굳이 배열로 할 필요가 없으니 answer의 값 자체를 올리는게 좋음
}

{
  function solution(n) {
    let answer = 0;
    for (let i = 1; i <= n; i++) {
      n % i === 0 ? answer++ : answer;
    }
    return answer;
  }
}

// ------------------------------------------------------------------------------------------

// 다른 사람의 풀이
{
  function solution(n) {
    let ans = 0;
    for (let i = 1; i < Math.sqrt(n); i++) if (n % i === 0) ans += 2;

    return Number.isInteger(Math.sqrt(n)) ? ans + 1 : ans;
  }
  // 1. for (let i = 1; i < Math.sqrt(n); i++)
  // 제곱근까지민 반복하는 이유
  // 어떤 수의 약수들을 나열하면 중앙엔 항상 제곱근이 존재
  // 제곱근보다 작은 약수를 하나 찾으면(예: 2), 그에 대응하는 큰 약수(예: 6)는 자동으로 결정 (12 / 2 = 6).
  // 전체를 다 돌 필요 없이 제곱근 바로 전까지만 확인하면 모든 순서쌍의 절반을 찾을 수 있다

  // 2. if (n % i === 0) ans += 2;
  // i가 약수라면, 그 짝꿍(n/i)도 반드시 존재하므로 한 번에 2개씩(ans += 2) 카운트
  // i=2일 때 (2, 6)과 (6, 2)라는 두 개의 순서쌍을 한꺼번에 센 것

  // 3. Number.isInteger(Math.sqrt(n)) ? ans + 1 : ans;
  // n이 '제곱수'일 때를 처리하는 예외 로직
  // n이 16이면 제곱근은 4이며, for문은 i<4 까지 돌기에 1,2만 확인한다. => (1, 16), (16, 1), (2, 8), (8, 2)까지 해서 ans는 4
  // 여기에 (4, 4)라는 순서쌍을 하나 더해줘야 한다. (4, 4)는 순서를 바꿔도 똑같으므로 1개만 추가
  // Math.sqrt(n)이 정수라면(즉, 제곱수라면) 기존 값에 +1을 해주고, 아니면 그대로 반환합니다.
}
{
  function solution(n) {
    return Array(n)
      .fill(1) // 배열의 길이를 n만큼 채움
      .map((v, idx) => v + idx) // 배열의 요소를 [1,2,3,...]로 채움
      .filter((v) => n % v === 0).length; // 위 풀이와 동일
  }
}
