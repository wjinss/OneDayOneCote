// 암호 해독
// 군 전략가 머쓱이는 전쟁 중 적군이 다음과 같은 암호 체계를 사용한다는 것을 알아냈습니다.

// 암호화된 문자열 cipher를 주고받습니다.
// 그 문자열에서 code의 배수 번째 글자만 진짜 암호입니다.
// 문자열 cipher와 정수 code가 매개변수로 주어질 때 해독된 암호 문자열을 return하도록 solution 함수를 완성해주세요.

// 제한사항
// 1 ≤ cipher의 길이 ≤ 1,000
// 1 ≤ code ≤ cipher의 길이
// cipher는 소문자와 공백으로만 구성되어 있습니다.
// 공백도 하나의 문자로 취급합니다.
// 입출력 예
// cipher	code	result
// "dfjardstddetckdaccccdegk"	4	"attack"
// "pfqallllabwaoclk"	2	"fallback"
// 입출력 예 설명
// 입출력 예 #1

// "dfjardstddetckdaccccdegk" 의 4번째, 8번째, 12번째, 16번째, 20번째, 24번째 글자를 합친 "attack"을 return합니다.
// 입출력 예 #2

// "pfqallllabwaoclk" 의 2번째, 4번째, 6번째, 8번째, 10번째, 12번째, 14번째, 16번째 글자를 합친 "fallback"을 return합니다.

// ------------------------------------------------------------------------------------------

// 나의 풀이

function solution(cipher, code) {
  return cipher
    .split("")
    .filter((str, idx) => (idx + 1) % code === 0)
    .join("");
}

// ------------------------------------------------------------------------------------------

// 다른 사람의 풀이
{
  function solution(cipher, code) {
    var answer = "";
    for (let i = code - 1; i < cipher.length; i += code) {
      answer += cipher[i];
    }
    return answer;
  }
}
// 풀이의 댓글 중 -
// 문자열은 불변인데 각 반복마다 문자열 덧셈이 일어나면 새로운 문자열을 생성하게 되므로 O((n / code)²) 만큼의 시간복잡도를 가지게 됩니다.
// 따라서 배열 선언을 하고 push로 추가한 후 join으로 문자열로 만드는 방법이 시간복잡도 측면에서O(n) 더 좋은 것 같아요.
// 지금 제한사항에서는 그냥 문자열 더해도 별 차이 없겠지만 문자열이 커지면 커질수록 성능차이가 날거에요!

// 해당 내용 해석
// 문자열 덧셈은 기존 문자열을 수정하는 것이 아닌, 기존 문자열 + 새로운 문자열을 메모리 어딘가에 새로 만듦
// 이전 문자열은 버려짐(GC)
// 문자열 덧셈(+=): 공책에 "안녕"이라고 적혀 있는데 "하세요"를 추가하고 싶습니다. 그런데 이 공책은 수정이 불가능합니다. 그래서 새 공책을 꺼내서 "안녕"을 처음부터 다시 옮겨 적고, 그 뒤에 "하세요"를 적습니다. 글자가 하나 추가될 때마다 매번 새 공책에 처음부터 다시 옮겨 적는 과정을 반복

// 시간 복잡도 차이 (O(N^2) vs O(N))
// - 문자열 덧셈 (+=)
// 길이가 1인 문자열을 만들 때 1만큼 복사, 2가 될 때 2만큼 복사
// 1 + 2 + 3 + ... + N 번의 연산이 필요합니다.
// 이를 수학적으로 계산하면 약 $\frac{N^2}{2}$이 되어, O(N^2) (이차 시간)의 복잡도를 가진다. => ?
// 데이터가 많아질수록 속도가 급격히 느려진다 => 아하!

// - 배열 사용(push, join)
// 배열은 내용 변경이 가능(Mutable) / 복사 과정 없음
// 마지막에 join으로 합칠 때만 딱 한 번 문자열을 만든다
// 이는 데이터 개수만큼만 비례하므로 $O(N)$ (선형 시간)의 복잡도를 가진다. => ?
// 훨씬 빠르다. => 아하!

// 성능 최적화 버전
{
  function solution(cipher, code) {
    var answerArr = [];

    for (let i = code - 1; i < cipher.length; i += code) {
      answerArr.push(cipher[i]);
    }

    return answerArr.join("");
  }
}
